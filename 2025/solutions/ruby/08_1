#!/usr/bin/env ruby
# frozen_string_literal: true

require_relative 'lib'

def distance(box_a, box_b)
  ax, ay, az = box_a
  bx, by, bz = box_b

  Math.sqrt((ax - bx).pow(2) + (ay - by).pow(2) + (az - bz).pow(2))
end

test_multiple(
  [
    ['distance ex1', {
      expected: 316.90219311326956,
      actual: distance([162, 817, 812], [425, 690, 689]),
    }],
    ['distance ex2', {
      expected: 1069.869618224576,
      actual: distance([431, 825, 988], [970, 615, 88]),
    }],
  ],
)

def solve(input, target_connections)
  boxes = input.map { it.split(',').map(&:to_i) }
  distances = []

  boxes[0..(boxes.length - 2)].each_with_index do |box_a, index_a|
    ((index_a + 1)..(boxes.length - 1)).each do |index_b|
      distances.push(
        [
          [index_a, index_b],
          distance(box_a, boxes[index_b]),
        ],
      )
    end
  end

  circuits = []

  distances
    .sort_by { it[1] }
    .first(target_connections)
    .each do |distance|
      index_a, index_b = distance.first

      circuit_index_with_a = circuits.find_index { it.any?(index_a) }
      circuit_index_with_b = circuits.find_index { it.any?(index_b) }

      if circuit_index_with_a && circuit_index_with_b
        next if circuit_index_with_a == circuit_index_with_b

        circuits[circuit_index_with_a].concat(circuits[circuit_index_with_b])
        circuits.delete_at(circuit_index_with_b)
      elsif circuit_index_with_a
        circuits[circuit_index_with_a].push(index_b)
      elsif circuit_index_with_b
        circuits[circuit_index_with_b].push(index_a)
      else
        circuits.push([index_a, index_b])
      end
    end

  circuits
    .sort_by(&:length)
    .reverse
    .first(3)
    .reduce(1) { |acc, curr| acc * curr.length }
end

test_multiple(
  [
    ['example', {
      expected: 40,
      actual: solve(get_input('08_example.txt'), 10),
    }],
    ['real', {
      expected: 62_186,
      actual: solve(get_input('08.txt'), 1000),
    }],
  ],
)

benchmark { solve(get_input('08.txt'), 1000) }
